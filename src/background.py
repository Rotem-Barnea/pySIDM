from typing import Any, Self, Unpack, cast

import numpy as np
import pandas as pd
from astropy.units import Quantity

from tqdm import tqdm

from . import nsphere, run_units
from .spatial_approximation import Lattice


class Mass_Distribution:
    """Background mass distribution"""

    def __init__(
        self, lattice: Lattice, M: Quantity['mass'], time: Quantity['time'], load_kwargs: dict[str, Any] = {}
    ) -> None:
        """Initialize a background mass distribution object, tracking a changing mass distribution external to the halo.

        Parameters:
            lattice: The spatial lattice on which the mass distribution is defined.
            M: The array of enclosed masses (`M(<=r)`), of shape `(n_snapshots,lattice_size)`. Every row is a snapshot (moment in time), and every column is the value at a `lattice` point.
            time: The times corresponding to each snapshot.
            load_kwargs: Keyword arguments passed to the file loading function, to use in future calls.

        Returns:
            The mass distribution object.
        """
        self.lattice = lattice
        self.M = M
        self.time = time
        self.load_kwargs = load_kwargs

    @classmethod
    def from_files(
        cls, Mtot: Quantity['mass'], files: pd.DataFrame | None = None, **kwargs: Unpack[nsphere.File_params]
    ) -> Self:
        """Initialize a background mass distribution object from input files, i.e. `NSphere` output.

        Parameters:
            Mtot: The total mass of the background distribution.
            files: A dataframe pointing to the files to be loaded, must include the columns 'path' and 'record_dtype'. If `None` the files dataframe will be generated by calling `nsphere.gather_files()`.
            kwargs: Keyword arguments passed to `nsphere.gather_files()` in the event files is None.

        Returns:
            A Background mass distribution object.
        """
        if files is None:
            files = nsphere.gather_files(**kwargs)
        data = np.vstack(
            [
                nsphere.load_file(path, dtype)['R']
                for path, dtype in tqdm(files[['path', 'record_dtype']].to_numpy(), desc='Load files')
            ]
        )
        lattice = Lattice(n_posts=10000, start=data.ravel().min() * 0.9, end=data.ravel().max() * 1.1, log=True)
        M = np.vstack([lattice.values_on_lattice_point_cumsum(lattice(d)) for d in data]) * Mtot / data.shape[1]
        time = Quantity(files.time.tolist())
        return cls(lattice, cast(Quantity, M), time, load_kwargs={**kwargs})

    def at_time(self, t: Quantity['time']) -> Quantity['mass']:
        """Calculate the enclosed mass array at a given time.

        Performs a linear interpolation between the two closest time points, and calculates the enclosed mass for every grid point (row in `self.M`).
        """
        mask = self.time == t
        if mask.any():
            return cast(Quantity, self.M[mask][0])
        mask = self.time < t
        if not mask.any():
            return cast(Quantity, self.M[0])
        elif mask.all():
            return cast(Quantity, self.M[-1])

        after = np.argmin(mask)
        before = after - 1
        f = (t - self.time[before]) / (self.time[after] - self.time[before])
        return cast(Quantity, self.M[before] * f + self.M[after] * (1 - f))

    def M_at_time(self, r: Quantity['length'], time: Quantity['time']) -> Quantity['mass']:
        """Calculate the mass at a given radius and time. Achieved by finding the nearest grid point and using linear interpolation in the time dimension (see `self.at_time()`)."""
        return cast(
            Quantity,
            self.at_time(time)[
                self.lattice(r.decompose(run_units.system).value)
                .clip(min=0, max=len(self.lattice) - 1)
                .astype(np.int64)
            ],
        )
