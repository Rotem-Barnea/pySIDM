import numpy as np
import pandas as pd
from tqdm import tqdm
from typing import Self, Unpack, cast
from astropy.units import Quantity
from . import nsphere
from .spatial_approximation import Lattice


class Mass_Distribution:
    """Background mass distribution"""

    def __init__(self, lattice: Lattice, M: Quantity['mass'], time: Quantity['time']) -> None:
        """Initialize a background mass distribution object, tracking a changing mass distribution external to the halo.

        Parameters:
            lattice: The spatial lattice on which the mass distribution is defined.
            M: The array of enclosed masses (M(<=r)), of shape (n_snapshots,lattice_size). Every row is a snapshot (moment in time), and every column is the value at a lattice point.
            time: The times corresponding to each snapshot.
        """
        self.lattice = lattice
        self.M = M
        self.time = time

    @classmethod
    def from_files(cls, lattice: Lattice, Mtot: Quantity['mass'], files: pd.DataFrame | None = None, **kwargs: Unpack[nsphere.File_params]) -> Self:
        """Initialize a background mass distribution object from input files, i.e. NSphere output.

        Parameters:
            lattice: The spatial lattice on which the mass distribution is defined.
            Mtot: The total mass of the background distribution.
            files: A dataframe pointing to the files to be loaded, must include the columns 'path' and 'record_dtype'. If None, the files dataframe will be generated by calling nsphere.gather_files().
            kwargs: Keyword arguments passed to nsphere.gather_files() in the event files is None.

        Returns:
            A Background mass distribution object.
        """
        if files is None:
            files = nsphere.gather_files(**kwargs)
        data = np.vstack([nsphere.load_file(path, dtype)['R'] for path, dtype in tqdm(files[['path', 'record_dtype']].to_numpy(), desc='Load files')])
        lattice.update(data.ravel())
        M = np.vstack([lattice.lattice_to_density_cumsum(lattice(d)) for d in data]) * Mtot / data.shape[1]
        time = Quantity(files.time.tolist())
        return cls(lattice, M, time)

    def at_time(self, t: Quantity['time']) -> Quantity['mass']:
        """Calculate the enclosed mass array at a given time.

        Performs a linear interpolation between the two closest time points, and calculates the enclosed mass for every grid point (row in self.M).
        """
        mask = self.time == t
        if mask.any():
            return cast(Quantity['mass'], self.M[mask][0])
        mask = self.time < t
        if not mask.any():
            return cast(Quantity['mass'], self.M[0])
        elif mask.all():
            return cast(Quantity['mass'], self.M[-1])

        after = np.argmin(mask)
        before = after - 1
        f = (t - self.time[before]) / (self.time[after] - self.time[before])
        return cast(Quantity['mass'], self.M[before] * f + self.M[after] * (1 - f))

    def M_at_time(self, r: Quantity['length'], time: Quantity['time']) -> Quantity['mass']:
        """Calculate the mass at a given radius and time. Achieved by finding the nearest grid point and using linear interpolation in the time dimension (see self.at_time())."""
        return cast(Quantity['mass'], self.at_time(time)[self.lattice(r.value).clip(min=0, max=len(self.lattice) - 1).astype(np.int64)])
